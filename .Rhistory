sub("(\\d{2})", "\\1\\.", .) %>%
as.numeric()
# price_by_sqm
imoveis_clean$price_by_sqm <- as.numeric(imoveis_clean$price_by_sqm)
# condominium_fee e iptu
imoveis_clean$condominium_fee <- str_replace_all(imoveis$condominium_fee, 'R\\$', '') %>%
str_replace_all('[:punct:]', '') %>%
as.numeric()
imoveis_clean$iptu <- str_replace_all(imoveis$iptu, 'R\\$', '') %>%
str_replace_all('[:punct:]', '') %>%
as.numeric()
imoveis_clean$area[which(imoveis$area == 30700)] <- NA
imoveis_clean <- imoveis_clean %>% filter(!(price == 18000))
imoveis_clean$condominium_fee[which(imoveis$condominium_fee == 460000)] <- NA
# imoveis_clean %>% filter(property_d %in% c(53512644, 83712188, 80671730))
View(imoveis_clean %>% filter(log(area) > 10 | log(price) < 10 | log(condominium_fee) > 10))
imoveis_clean %>% filter(rooms > 4) %>% arrange(desc(rooms))
imoveis_clean %>% filter(bathrooms > 6) %>% arrange(desc(bathrooms))
imoveis_clean %>% filter(garage > 5) %>% arrange(desc(garage))
# Como nao e possivel checar a fonte com precisao, deixarei os valores a menos que muito bizarros
# outliers de area e price: informações muito discrepantes em relação à realidade. Provavelmente, erros de digitação
imoveis_clean$area[which(imoveis$area == 30700)] <- NA
imoveis_clean <- imoveis_clean %>% filter(!(price == 18000))
imoveis_clean$condominium_fee[which(imoveis$condominium_fee == 460000)] <- NA
# por estarem completamente fora do espaço geografico do resto da amostra, colocarei seus bairros como NA
imoveis_clean$bairro[which(imoveis$property_d %in% c(53512644, 83712188, 80671730))] <- NA
# o apartamento com mais de 54 banheiros parece muito fora da media em relacao ao seu preco e area
imoveis_clean$bathrooms[which(imoveis$bathrooms == 54)] <- NA
# agregação dos valores para não causar overfitting pela baixa quantidade de valores
roomsBathGarage <- imoveis_clean %>%
select(c(rooms, bathrooms, garage)) %>%
mutate(rooms_coerc = ifelse(rooms > 4, 4, rooms),
bathrooms_coerc = ifelse(bathrooms > 6, 6, bathrooms),
garage_coerc = ifelse(garage > 5, 5, garage))
## Procurar agregacoes uteis em rua, condominio e agente
# criacao dos dfs comas supostas novas variaveis de interesse
imoveis_clean_rua <- imoveis_clean %>%
group_by(rua) %>%
summarise(total_a = n(),
media_p = mean(price_by_sqm, na.rm = T)) %>%
filter(!(is.na(rua)))# %>%
# mutate(QTL_t = case_when(
#total_a <= quantile(total_a, probs = .2) ~ '1o',
#total_a <= quantile(total_a, probs = .4) ~ '2o',
#  total_a <= quantile(total_a, probs = .6) ~ 'baixo',
#   total_a <= quantile(total_a, probs = .9) ~ 'medio',
#   TRUE ~ 'alto'
# ),
# como media_p possui apenas as extremidades diferentes, aqui dividirei em mais quantis
# QTL_m = case_when(
#media_p <= quantile(media_p, probs = (1/6)) ~ '1o',
#media_p <= quantile(media_p, probs = (2/6)) ~ '2o',
#media_p <= quantile(media_p, probs = (3/6)) ~ '3o',
# media_p <= quantile(media_p, probs = .90) ~ 'baixa',
#  media_p <= quantile(media_p, probs = .95) ~ 'media',
# TRUE ~ 'alta'
# ))
imoveis_clean_condominio <- imoveis_clean %>%
group_by(condominio) %>%
summarise(total_a = n(),
media_p = mean(price_by_sqm, na.rm = T)) %>%
filter(!(is.na(condominio))) #%>%
#mutate(QTL_t = case_when(
#total_a <= quantile(total_a, probs = .2) ~ '1o',
#total_a <= quantile(total_a, probs = .4) ~ '2o',
#total_a <= quantile(total_a, probs = .6) ~ '3o',
#  total_a <= quantile(total_a, probs = .90) ~ 'baixo',
#  TRUE ~ 'alto'
# ),
# dispersAo deste é muito uniforme, então focarei apenas nos extremos
# QTL_m = case_when(
#media_p <= quantile(media_p, probs = .10) ~ 'baixo',
# media_p <= quantile(media_p, probs = .975) ~ 'baixa',
# media_p <= quantile(media_p, probs = .99) ~ 'media',
# TRUE ~ 'alta'
# ))
# como ha agencias sem nenhuma entrada, filtro antes de achar as variaves finais
imoveis_clean_agent <- imoveis_clean %>%
group_by(agent) %>%
summarise(total_a = n(),
media_p = mean(price_by_sqm, na.rm = T)) %>%
filter(!(is.na(agent))) %>%
filter(!(is.na(media_p))) #%>%
#mutate(QTL_t = case_when(
#total_a <= quantile(total_a, probs = .2) ~ '1o',
#total_a <= quantile(total_a, probs = .4) ~ '2o',
#total_a <= quantile(total_a, probs = .8) ~ 'baixo',
#total_a <= quantile(total_a, probs = .90) ~ 'baixo',
#TRUE ~ 'alto'
#),
# dispersAo deste é muito uniforme, então focarei apenas nos extremos
# QTL_m = case_when(
# media_p <= quantile(media_p, probs = .975) ~ 'baixa',
# media_p <= quantile(media_p, probs = .99) ~ 'media',
# TRUE ~ 'alta'
#))
# plot total_a
var_t <- list(imoveis_clean_rua %>% arrange(desc(total_a)),
imoveis_clean_condominio %>% arrange(desc(total_a)),
imoveis_clean_agent %>% arrange(desc(total_a)))
plots_total <- list()
for (i in 1:length(var_t)){
plots_total[[i]] <- ggplot(var_t[[i]], aes(x = factor(var_t[[i]][[1]], levels = var_t[[i]][[1]]),
y = total_a)) +
geom_bar(stat="identity", width=.5) +
coord_flip() +
labs(title=paste('Anúncios x ', names(var_t[[i]])[[1]]),
x = names(names(var_t[[i]])[[1]]),
y = 'Anúncios')
print(plots_total[[i]])
}
# plot da media_p
var_m <- list(imoveis_clean_rua %>% arrange(desc(media_p)),
imoveis_clean_condominio %>% arrange(desc(media_p)),
imoveis_clean_agent %>% arrange(desc(media_p)))
plots_media <- list()
for (i in 1:length(var_m)){
plots_media[[i]] <- ggplot(var_m[[i]], aes(x = factor(var_m[[i]][[1]], levels = var_m[[i]][[1]]),
y = media_p)) +
geom_bar(stat="identity", width=.5) +
coord_flip() +
labs(title=paste('Media x ', names(var_m[[i]])[[1]]),
x = names(names(var_m[[i]])[[1]]),
y = 'Media')
print(plots_media[[i]])
}
# variaveis criadas
vars_rua <- imoveis_clean_rua %>% select(rua, anuncio_rua = total_a, valores_rua = media_p)
vars_condo <- imoveis_clean_condominio %>% select(condominio, anuncio_condo = total_a, valores_condo = media_p)
vars_agente <- imoveis_clean_agent %>% select(agent, anuncio_agente = total_a, valores_agente = media_p)
### Modelo preditivo
# df final para analise e com variaveis novas
imoveis_final <- imoveis_clean %>%
left_join(roomsBathGarage) %>%
left_join(vars_rua) %>%
left_join(vars_condo) %>%
left_join(vars_agente) %>%
select(-c(Data, rua, numero, bairro, price_by_sqm, condominio, rooms, bathrooms, garage,agent, agent_number,
latitude, longitude, property_d, url))
# Criacao de versao usavel do df original para comparacao
imoveis_bench <- imoveis %>%
filter(!(price == 18000)) %>%
select(-c(X.U.FEFF.date, rua, numero, bairro, price_by_sqm, condominio, agent, agent_number, latitude,
longitude, property_d, url))
# separação das amostras de treino e teste
sample <- createDataPartition(imoveis_final$price, times = 1, list = F, p = .7, na.rm = T)
train_sample <- imoveis_final[sample, ]
test_sample <- imoveis_final[-sample, ]
train_sample_bench <- imoveis_bench[sample, ]
test_sample_bench <- imoveis_bench[-sample, ]
# Criacao de versao usavel do df original para comparacao
imoveis_bench <- imoveis %>%
filter(!(price == 18000)) %>%
select(-c(X.U.FEFF.date, rua, numero, bairro, price_by_sqm, condominio, agent, agent_number, latitude,
longitude, property_d, url))
# separação das amostras de treino e teste
sample <- createDataPartition(imoveis_final$price, times = 1, list = F, p = .7)
train_sample <- imoveis_final[sample, ]
test_sample <- imoveis_final[-sample, ]
train_sample_bench <- imoveis_bench[sample, ]
test_sample_bench <- imoveis_bench[-sample, ]
View(test_sample_bench)
imoveis_bench <- imoveis_clean %>%
filter(!(price == 18000)) %>%
select(-c(X.U.FEFF.date, rua, numero, bairro, price_by_sqm, condominio, agent, agent_number, latitude,
longitude, property_d, url))
train_sample_bench <- imoveis_bench[sample, ]
test_sample_bench <- imoveis_bench[-sample, ]
View(test_sample_bench)
imoveis_bench <- imoveis_clean %>%
filter(!(price == 18000)) %>%
select(-c(X.U.FEFF.date, rua, numero, bairro, price_by_sqm, condominio, agent, agent_number, latitude,
longitude, property_d, url))
imoveis_bench <- imoveis_clean %>%
filter(!(price == 18000)) %>%
select(-c(Data, rua, numero, bairro, price_by_sqm, condominio, agent, agent_number, latitude,
longitude, property_d, url))
train_sample_bench <- imoveis_bench[sample, ]
test_sample_bench <- imoveis_bench[-sample, ]
View(test_sample_bench)
train_fact <- toFactor(train_sample, c('rooms_coerc', 'bathrooms_coerc','garage_coerc'))
test_fact <- toFactor(test_sample, c('rooms_coerc', 'bathrooms_coerc','garage_coerc'))
train_fact_bench <- toFactor(train_sample_bench, c('rooms', 'bathrooms','garage'))
test_fact_bench <- toFactor(test_sample_bench, c('rooms', 'bathrooms','garage'))
# funcao para transformar variaveis em fact
toFactor <- function(df, features) {
for (feature in features) {
df[[feature]] <- factor(df[[feature]], exclude = NULL)
# exclude é importantíssimo pra considerar NA como classe
}
return(df)
}
train_fact <- toFactor(train_sample, c('rooms_coerc', 'bathrooms_coerc','garage_coerc'))
test_fact <- toFactor(test_sample, c('rooms_coerc', 'bathrooms_coerc','garage_coerc'))
train_fact_bench <- toFactor(train_sample_bench, c('rooms', 'bathrooms','garage'))
test_fact_bench <- toFactor(test_sample_bench, c('rooms', 'bathrooms','garage'))
# knnImpute é extremamente lento, só é usável em outas situações. Optei pelo median
preprocessParams_train <- preProcess(train_fact, method=c("medianImpute", "center", "scale"))
preprocessParams_test <- preProcess(test_fact, method=c("medianImpute", "center", "scale"))
preprocessParams_train_bench <- preProcess(train_fact_bench, method=c("medianImpute", "center", "scale"))
preprocessParams_test_bench <- preProcess(test_fact_bench, method=c("medianImpute", "center", "scale"))
# Pre processamento dos sets
# knnImpute é extremamente lento, só é usável em outas situações. Optei pelo median
preprocessParams_train <- preProcess(train_fact, method=c("medianImpute", "center", "scale"))
preprocessParams_test <- preProcess(test_fact, method=c("medianImpute", "center", "scale"))
preprocessParams_train_bench <- preProcess(train_fact_bench, method=c("medianImpute", "center", "scale"))
preprocessParams_test_bench <- preProcess(test_fact_bench, method=c("medianImpute", "center", "scale"))
# Sets prontos para uso
train_preproc <- predict(preprocessParams_train, train_fact)
test_preproc <- predict(preprocessParams_test, test_fact)
train_preproc_bench <- predict(preprocessParams_train_bench, preprocessParams_train)
test_preproc_bench <- predict(preprocessParams_test_bench, preprocessParams_test)
preprocessParams_train_bench <- preProcess(train_fact_bench, method=c("medianImpute", "center", "scale"))
preprocessParams_test_bench <- preProcess(test_fact_bench, method=c("medianImpute", "center", "scale"))
train_preproc_bench <- predict(preprocessParams_train_bench, train_fact_bench)
test_preproc_bench <- predict(preprocessParams_test_bench, test_fact_bench)
#1
model1 <- train(CreditStatus ~ ., data = train_sample,
family = binomial(),
method = "lm",
trControl = trainControl(method = 'none'),
metric = 'RMSE')
# Carregando pacote necessario e iniciando seed do projeto
library(caret)
library(mlbench)
model1 <- train(CreditStatus ~ ., data = train_sample,
family = binomial(),
method = "lm",
trControl = trainControl(method = 'none'),
metric = 'RMSE')
model1 <- train(price ~ .,
data = train_preproc,
trControl = trainControl(method = 'none'),
metric = 'RMSE')
control <- trainControl(method="cv", number=10)
model2 <- train(price ~ .,
data = train_preproc,
method = "lm",
trControl = control,
metric = 'RMSE')
plot(varImp(model2, scale=FALSE))
model1 <- train(price ~ .,
data = train_preproc,
trControl = control,
metric = 'RMSE')
model1 <- train(price ~ .,
data = train_preproc_bench,
method = "lm",
trControl = control,
metric = 'RMSE')
model1
model2
control_rfe <- rfeControl(functions=lmFuncs, method="cv", number=10)
results <- rfe(price ~ ., data = train_preproc, sizes=c(1:15), rfeControl=control_rfe)
varImp(results, scale=FALSE)
plot(results, type=c("g", "o"))
model2 <- train(price ~ garage_coerc5,
data = train_preproc,
method = "lm",
trControl = control,
metric = 'RMSE')
model2 <- train(price ~
area +
garage_coerc +
valores_condo+
rooms_coerc +
anuncio_condo +
valores_agente +
valores_rua,
data = train_preproc,
method = "lm",
trControl = control,
metric = 'RMSE')
plot(varImp(model2, scale=FALSE))
model2
# Create model_list
model_list <- list(BENCH = model1, FE_FS = model2)
# Pass model_list to resamples(): resamples
resamples <- resamples(model_list)
# Create bwplot
dotplot(resamples, metric = 'ROC')
# Create bwplot
dotplot(resamples)
# Create bwplot
dotplot(resamples, metric = 'RMSE')
model2 <- train(price ~ .,
data = train_preproc,
method = "lm",
trControl = control,
metric = 'RMSE')
model2
model1
# Create model_list
model_list <- list(BENCH = model1, FE_FS = model2)
# Pass model_list to resamples(): resamples
resamples <- resamples(model_list)
# Summarize the results
#summary(resamples)
# Create bwplot
dotplot(resamples, metric = 'RMSE')
# Create bwplot
dotplot(resamples, metric = 'R')
# Create bwplot
dotplot(resamples)
pred1 <- predict(model1, test_preproc_bench)
pred2 <- predict(model2, test_preproc)
test_Score1 <-data.frame(obs = test_preproc_bench$price, pred= pred1)
test_Score2 <-data.frame(obs = test_preproc$price, pred= pred2)
defaultSummary(test_Score1)
######
# score modelo
pred1 <- predict(model1, test_preproc_bench)
pred2 <- predict(model2, test_preproc)
test_Score2 <-data.frame(obs = test_preproc$price, pred= pred2)
defaultSummary(test_Score2)
######
# score modelo
pred1 <- predict(model1, test_preproc_bench)
######
# score modelo
pred1 <- predict(model1, test_preproc_bench, type="response", se.fit=FALSE)
######
# score modelo
pred1 <- predict(model1, test_preproc_bench, se.fit=FALSE)
######
# score modelo
pred1 <- predict(model1, test_preproc_bench, type="response", se.fit=FALSE)
names(imoveis_final)
# Controle para todos os modelos
control <- trainControl(method="cv", number=10)
# modelo com as originais
model1 <- train(price ~
area +
condominium_fee +
iptu +
rooms_coerc +
bathrooms_coerc +
garage_coerc + ,
data = train_preproc,
method = "lm",
trControl = control,
metric = 'RMSE')
model1 <- train(price ~
area +
condominium_fee +
iptu +
rooms_coerc +
bathrooms_coerc +
garage_coerc,
data = train_preproc,
method = "lm",
trControl = control,
metric = 'RMSE')
model1
model2
plot(varImp(model2, scale=FALSE))
model_list <- list(Originais = model1, Originais_eNovas = model2)
resamples <- resamples(model_list)
dotplot(resamples)
dotplot(resamples, metric = 'RMSE')
pred1 <- predict(model1, test_preproc)
pred2 <- predict(model2, test_preproc)
test_Score1 <-data.frame(obs = test_preproc_bench$price, pred= pred1)
test_Score2 <-data.frame(obs = test_preproc$price, pred= pred2)
test_Score1 <-data.frame(obs = test_preproc$price, pred= pred1)
test_Score2 <-data.frame(obs = test_preproc$price, pred= pred2)
defaultSummary(test_Score1)
defaultSummary(test_Score2)
install.packages("drat", repos="https://cran.rstudio.com")
drat:::addRepo("dmlc")
install.packages("xgboost", repos="http://dmlc.ml/drat/", type = "source")
install.packages("drat", repos="https://cran.rstudio.com")
install.packages("xgboost", repos="http://dmlc.ml/drat/", type = "source")
require(xgboost)
data(agaricus.train, package='xgboost')
View(agaricus.train)
str(agaricus.train)
bstSparse <- xgboost(data = train$data, label = train$label, max.depth = 2, eta = 1, nthread = 2, nrounds = 2, objective = "binary:logistic")
options (error = browser)
train <- agaricus.train
bstSparse <- xgboost(data = train$data, label = train$label, max.depth = 2, eta = 1, nthread = 2, nrounds = 2, objective = "binary:logistic")
install.packages('vtreat')
source('~/GitHub/Case_InfoProp_R/Case_InfoProp.R', encoding = 'UTF-8', echo=TRUE)
source('~/GitHub/Case_InfoProp_R/Case_InfoProp.R', encoding = 'UTF-8', echo=TRUE)
source('~/GitHub/Case_InfoProp_R/Case_InfoProp.R', encoding = 'UTF-8', echo=TRUE)
source('~/GitHub/Case_InfoProp_R/Case_InfoProp.R', encoding = 'UTF-8', echo=TRUE)
source('~/GitHub/Case_InfoProp_R/Case_InfoProp.R', encoding = 'UTF-8', echo=TRUE)
imoveis_clean <- imoveis_clean %>% filter(!(price == 18000))
var_t <- list(imoveis_clean_rua %>% arrange(desc(total_a)),
imoveis_clean_condominio %>% arrange(desc(total_a)),
imoveis_clean_agent %>% arrange(desc(total_a)))
plots_total <- list()
for (i in 1:length(var_t)){
plots_total[[i]] <- ggplot(var_t[[i]], aes(x = factor(var_t[[i]][[1]], levels = var_t[[i]][[1]]),
y = total_a)) +
geom_bar(stat="identity", width=.5) +
coord_flip() +
labs(title=paste('Anúncios x ', names(var_t[[i]])[[1]]),
x = names(names(var_t[[i]])[[1]]),
y = 'Anúncios')
print(plots_total[[i]])
}
imoveis_final <- imoveis_clean %>%
left_join(roomsBathGarage) %>%
left_join(vars_rua) %>%
left_join(vars_condo) %>%
left_join(vars_agente) %>%
select(-c(Data, rua, numero, bairro, price_by_sqm, condominio, rooms, bathrooms, garage,agent, agent_number,
latitude, longitude, property_d, url))
imoveis_final <- imoveis_clean %>%
left_join(roomsBathGarage)
View(imoveis_clean)
# agregação dos valores para não causar overfitting pela baixa quantidade de valores
roomsBathGarage <- imoveis_clean %>%
select(c(rooms, bathrooms, garage, property_d)) %>%
mutate(rooms_coerc = ifelse(rooms > 4, 4, rooms),
bathrooms_coerc = ifelse(bathrooms > 6, 6, bathrooms),
garage_coerc = ifelse(garage > 5, 5, garage))
# df final para analise e com variaveis novas
imoveis_final <- imoveis_clean %>%
left_join(roomsBathGarage, by = c('property_d')) %>%
left_join(vars_rua) %>%
left_join(vars_condo) %>%
left_join(vars_agente) %>%
select(-c(Data, rua, numero, bairro, price_by_sqm, condominio, rooms, bathrooms, garage,agent, agent_number,
latitude, longitude, property_d, url))
imoveis_final <- imoveis_clean %>%
left_join(roomsBathGarage, by = c('property_d'))
options (error = browser)
imoveis_final <- imoveis_clean %>%
left_join(roomsBathGarage, by = c('property_d')) %>%
left_join(vars_rua) %>%
left_join(vars_condo) %>%
left_join(vars_agente) %>%
select(-c(Data, rua, numero, bairro, price_by_sqm, condominio, rooms, bathrooms, garage,agent, agent_number,
latitude, longitude, property_d, url))
a
imoveis_final <- imoveis_clean %>%
left_join(roomsBathGarage, by = c('property_d')) %>%
left_join(vars_rua) %>%
left_join(vars_condo) %>%
left_join(vars_agente) %>%
select(-c(Data, rua, numero, bairro, price_by_sqm, condominio, rooms, bathrooms, garage,agent, agent_number,
latitude, longitude, property_d, url))
# df final para analise e com variaveis novas
imoveis_final <- imoveis_clean %>%
left_join(roomsBathGarage, by = c('property_d')) %>%
left_join(vars_rua) %>%
left_join(vars_condo) %>%
left_join(vars_agente) %>%
select(-c(Data, rua, numero, bairro, price_by_sqm, condominio, rooms, bathrooms, garage,agent, agent_number,
latitude, longitude, property_d, url))
imoveis_final <- imoveis_clean %>%
left_join(roomsBathGarage, by = c('property_d')) %>%
left_join(vars_rua) %>%
left_join(vars_condo)
imoveis_final <- imoveis_clean %>%
left_join(roomsBathGarage, by = c('property_d')) %>%
left_join(vars_rua) %>%
left_join(vars_condo) %>%
left_join(vars_agente)
View(imoveis_final)
roomsBathGarage <- imoveis_clean %>%
select(c(rooms, bathrooms, garage, property_d)) %>%
mutate(rooms_coerc = ifelse(rooms > 4, 4, rooms),
bathrooms_coerc = ifelse(bathrooms > 6, 6, bathrooms),
garage_coerc = ifelse(garage > 5, 5, garage)) %>%
select(-c(rooms, bathrooms, garage, property_d))
# df final para analise e com variaveis novas
imoveis_final <- imoveis_clean %>%
left_join(roomsBathGarage, by = c('property_d')) %>%
left_join(vars_rua) %>%
left_join(vars_condo) %>%
left_join(vars_agente) %>%
select(-c(Data, rua, numero, bairro, price_by_sqm, condominio, rooms, bathrooms, garage,agent, agent_number,
latitude, longitude, property_d, url))
imoveis_final <- imoveis_clean %>%
left_join(roomsBathGarage, by = c('property_d'))
View(roomsBathGarage)
roomsBathGarage <- imoveis_clean %>%
select(c(rooms, bathrooms, garage, property_d)) %>%
mutate(rooms_coerc = ifelse(rooms > 4, 4, rooms),
bathrooms_coerc = ifelse(bathrooms > 6, 6, bathrooms),
garage_coerc = ifelse(garage > 5, 5, garage)) %>%
select(-c(rooms, bathrooms, garage))
# df final para analise e com variaveis novas
imoveis_final <- imoveis_clean %>%
left_join(roomsBathGarage, by = c('property_d')) %>%
left_join(vars_rua) %>%
left_join(vars_condo) %>%
left_join(vars_agente) %>%
select(-c(Data, rua, numero, bairro, price_by_sqm, condominio, rooms, bathrooms, garage,agent, agent_number,
latitude, longitude, property_d, url))
View(imoveis_final)
source('~/GitHub/Case_InfoProp_R/Case_InfoProp.R', encoding = 'UTF-8', echo=TRUE)
#Carregando pacote necessario e iniciando seed do projeto
library(caret)
library(vtreat)
library(xgboost)
set.seed(666)
sample <- createDataPartition(imoveis_final$price, times = 1, list = F, p = .7)
train_sample <- imoveis_final[sample, ]
test_sample <- imoveis_final[-sample, ]
View(imoveis_final)
## Pre processamento usando vtreat
X_train <- train_sample[-1]
View(X_train)
y_trains <- train_sample[1]
vars_input <- names(X_train)
treatplan <- designTreatmentsZ(X_train, vars)
vars_input <- names(X_train)
treatplan <- designTreatmentsZ(X_train, vars_input)
